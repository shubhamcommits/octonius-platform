name: ðŸ—ï¸ 100% Pipeline-Native Terraform

on:
  push:
    branches: 
      - master
      - development
      - 'feature/*'
      - 'hotfix/*'
  pull_request:
    branches: 
      - master
      - development
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (auto-detected from branch if not provided)'
        required: false
        type: string
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: '1.6.0'
  PROJECT_NAME: 'octonius'

jobs:
  setup:
    name: ðŸ”§ Setup Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-apply: ${{ steps.action.outputs.should-apply }}
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ” Debug Workflow Context
        run: |
          echo "ðŸ” Workflow Debug Information:"
          echo "Event Name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Ref Name: ${{ github.ref_name }}"
          echo "Head Ref: ${{ github.head_ref }}"
          echo "Base Ref: ${{ github.base_ref }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          
          # Show environment variables
          echo ""
          echo "ðŸ”§ Environment Variables:"
          echo "TF_VERSION: ${{ env.TF_VERSION }}"
          echo "PROJECT_NAME: ${{ env.PROJECT_NAME }}"
          
          # Show if this is a push or PR
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "ðŸ“¤ This is a PUSH event to: ${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ðŸ“‹ This is a PULL_REQUEST event from: ${{ github.head_ref }} to: ${{ github.base_ref }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ðŸŽ¯ This is a MANUAL workflow dispatch"
            echo "Manual action: ${{ github.event.inputs.action }}"
            echo "Manual environment: ${{ github.event.inputs.environment }}"
          fi

      - name: ðŸŽ¯ Determine Environment
        id: env
        run: |
          # Get branch name
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.head_ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi
          
          # Use manual environment if provided
          if [[ -n "${{ github.event.inputs.environment }}" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            # Convert branch to environment
            case "$BRANCH" in
              master)
                ENV="prod"
                ;;
              development|dev)
                ENV="dev"
                ;;
              feature/*)
                ENV=$(echo "$BRANCH" | sed 's|feature/|feature-|' | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')
                ;;
              hotfix/*)
                ENV=$(echo "$BRANCH" | sed 's|hotfix/|hotfix-|' | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')
                ;;
              *)
                ENV=$(echo "$BRANCH" | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]')
                ;;
            esac
          fi
          
          echo "Branch: $BRANCH"
          echo "Environment: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT

      - name: ðŸŽ¯ Determine Action
        id: action
        run: |
          echo "ðŸŽ¯ Determining whether to apply infrastructure..."
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ðŸ“ Manual workflow dispatch detected"
            echo "Action input: ${{ github.event.inputs.action }}"
            if [[ "${{ github.event.inputs.action }}" == "apply" || "${{ github.event.inputs.action }}" == "destroy" ]]; then
              echo "âœ… Should apply: true (manual apply/destroy)"
              echo "should-apply=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ Should apply: false (manual plan only)"
              echo "should-apply=false" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ github.ref_name }}" == "master" || "${{ github.ref_name }}" == "development" ]]; then
            echo "âœ… Should apply: true (push to master or development branch)"
            echo "Branch: ${{ github.ref_name }}"
            echo "should-apply=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Should apply: false (not master/development branch or manual apply)"
            echo "Current branch: ${{ github.ref_name }}"
            echo "should-apply=false" >> $GITHUB_OUTPUT
          fi

      - name: âš™ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ” Terraform Format Check
        run: terraform fmt -check -recursive terraform/

  plan:
    name: ðŸ“‹ Plan (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: setup
    
    steps:
      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ðŸ—ƒï¸ Create DynamoDB Table (State Locking)
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          TABLE_NAME="${ENV}-${{ env.PROJECT_NAME }}-terraform-locks-${{ secrets.AWS_REGION }}"
          
          echo "ðŸ—ƒï¸ Setting up DynamoDB table for state locking: $TABLE_NAME"
          
          # Create DynamoDB table if it doesn't exist
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null >/dev/null; then
            echo "ðŸ”¨ Creating DynamoDB table: $TABLE_NAME"
            
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 \
              --tags \
                Key=Environment,Value="$ENV" \
                Key=Project,Value="${{ env.PROJECT_NAME }}" \
                Key=Purpose,Value=terraform-locks \
                Key=Repository,Value="${{ github.repository }}"
            
            echo "â³ Waiting for DynamoDB table to become active..."
            aws dynamodb wait table-exists --table-name "$TABLE_NAME"
            echo "âœ… DynamoDB table created and active"
          else
            echo "âœ… DynamoDB table already exists: $TABLE_NAME"
          fi
          
          # Get bucket name based on environment
          case "$ENV" in
            prod)
              BUCKET_NAME="${{ secrets.PROD_S3_BUCKET }}"
              ;;
            *)
              BUCKET_NAME="${{ secrets.DEV_S3_BUCKET }}"
              ;;
          esac
          echo "ðŸ“¦ Using existing S3 bucket: $BUCKET_NAME"

      - name: ðŸ“ Generate Backend Configuration
        run: |
          mkdir -p terraform/config
          
          # Get environment and determine bucket
          ENV="${{ needs.setup.outputs.environment }}"
          case "$ENV" in
            prod)
              BUCKET_NAME="${{ secrets.PROD_S3_BUCKET }}"
              ;;
            *)
              BUCKET_NAME="${{ secrets.DEV_S3_BUCKET }}"
              ;;
          esac
          
          # Validate bucket name is not empty
          if [[ -z "$BUCKET_NAME" ]]; then
            echo "âŒ ERROR: S3 bucket name is empty for environment: $ENV"
            case "$ENV" in
              prod)
                echo "Missing secret: PROD_S3_BUCKET"
                ;;
              *)
                echo "Missing secret: DEV_S3_BUCKET"
                ;;
            esac
            exit 1
          fi
          
          echo "ðŸ“ Generating backend configuration for environment: $ENV"
          
          # Generate backend configuration as a separate .tf file
          cat > terraform/backend.tf << EOF
          # Backend Configuration - Generated by GitHub Actions
          # Generated on: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          terraform {
            backend "s3" {
              bucket         = "$BUCKET_NAME"
              key            = "terraform/$ENV/terraform.tfstate"
              region         = "${{ secrets.AWS_REGION }}"
              encrypt        = true
              dynamodb_table = "$ENV-${{ env.PROJECT_NAME }}-terraform-locks-${{ secrets.AWS_REGION }}"
            }
          }
          EOF
          
          # Also create the .hcl file for reference
          cat > terraform/config/backend.hcl << EOF
          bucket         = "$BUCKET_NAME"
          key            = "terraform/$ENV/terraform.tfstate"
          region         = "${{ secrets.AWS_REGION }}"
          encrypt        = true
          dynamodb_table = "$ENV-${{ env.PROJECT_NAME }}-terraform-locks-${{ secrets.AWS_REGION }}"
          EOF

      - name: ðŸ“ Generate Variables Configuration
        run: |
          # Determine environment-specific settings
          ENV="${{ needs.setup.outputs.environment }}"
          
          case "$ENV" in
            prod)
              VPC_CIDR="10.0.0.0/16"
              PUBLIC_SUBNETS='["10.0.1.0/24", "10.0.2.0/24"]'
              PRIVATE_SUBNETS='["10.0.10.0/24", "10.0.20.0/24"]'
              SINGLE_NAT="false"
              ;;
            dev)
              VPC_CIDR="10.1.0.0/16"
              PUBLIC_SUBNETS='["10.1.1.0/24", "10.1.2.0/24"]'
              PRIVATE_SUBNETS='["10.1.10.0/24", "10.1.20.0/24"]'
              SINGLE_NAT="true"
              ;;
            *)
              # For feature branches and other environments
              ENV_HASH=$(echo -n "$ENV" | md5sum | cut -c1-2)
              SECOND_OCTET=$((0x$ENV_HASH % 240 + 10))
              VPC_CIDR="10.${SECOND_OCTET}.0.0/16"
              PUBLIC_SUBNETS="[\"10.${SECOND_OCTET}.1.0/24\", \"10.${SECOND_OCTET}.2.0/24\"]"
              PRIVATE_SUBNETS="[\"10.${SECOND_OCTET}.10.0/24\", \"10.${SECOND_OCTET}.20.0/24\"]"
              SINGLE_NAT="true"
              ;;
          esac
          
          cat > terraform/config/terraform.tfvars << EOF
          environment  = "$ENV"
          project_name = "${{ env.PROJECT_NAME }}"
          aws_region   = "${{ secrets.AWS_REGION }}"
          
          vpc_cidr           = "$VPC_CIDR"
          public_subnets     = $PUBLIC_SUBNETS
          private_subnets    = $PRIVATE_SUBNETS
          single_nat_gateway = $SINGLE_NAT
          EOF

      - name: ðŸ“ Generate Locals Configuration
        run: |
          # Determine S3 bucket for locals reference
          ENV="${{ needs.setup.outputs.environment }}"
          case "$ENV" in
            prod)
              BUCKET_NAME="${{ secrets.PROD_S3_BUCKET }}"
              ;;
            dev)
              BUCKET_NAME="${{ secrets.DEV_S3_BUCKET }}"
              ;;
            *)
              # For feature branches, use dev bucket with different key path
              BUCKET_NAME="${{ secrets.DEV_S3_BUCKET }}"
              ;;
          esac
          
          # Validate bucket name is not empty
          if [[ -z "$BUCKET_NAME" ]]; then
            echo "âŒ ERROR: S3 bucket name is empty for locals generation"
            echo "Environment: $ENV"
            case "$ENV" in
              prod)
                echo "Missing secret: PROD_S3_BUCKET"
                ;;
              *)
                echo "Missing secret: DEV_S3_BUCKET"
                ;;
            esac
            exit 1
          fi
          
          cat > terraform/locals.tf << EOF
          # Dynamic Terraform Locals - Generated by GitHub Actions
          # Generated on: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          locals {
            # Environment and project info
            environment  = var.environment
            project_name = var.project_name
            aws_region   = var.aws_region
            account_id   = "${{ secrets.AWS_ACCOUNT_ID }}"
            
            # Computed names and identifiers
            name_prefix = "\${local.environment}-\${local.project_name}"
            
            # Resource naming
            vpc_name = "\${local.name_prefix}-vpc"
            
            # Backend resources (for reference)
            state_bucket         = "$BUCKET_NAME"
            state_dynamodb_table = "\${local.environment}-\${local.project_name}-terraform-locks-\${local.aws_region}"
            
            # Common tags applied to all resources
            common_tags = {
              Environment = local.environment
              Project     = local.project_name
              ManagedBy   = "terraform"
              Repository  = "${{ github.repository }}"
              Branch      = local.environment # Since env is derived from branch
              Account     = local.account_id
              Region      = local.aws_region
              Owner      = "Octonius-Team"
              CreatedBy   = "${{ github.actor }}"
              CreatedAt   = "$(date -u +"%Y-%m-%d")"
            }
            
            # Environment-specific configurations
            is_production     = local.environment == "prod"
            is_development    = local.environment == "dev"
            is_feature_branch = !local.is_production && !local.is_development
          }
          EOF

      - name: ðŸ” Verify Configuration Files
        working-directory: terraform
        run: |
          echo "ðŸ” Verifying configuration files for ${{ needs.setup.outputs.environment }} environment..."
          
          # Check required files exist
          if [[ ! -f "backend.tf" ]]; then
            echo "âŒ ERROR: backend.tf not found!"
            exit 1
          fi
          
          if [[ ! -f "locals.tf" ]]; then
            echo "âŒ ERROR: locals.tf not found!"
            exit 1
          fi
          
          if [[ ! -f "config/terraform.tfvars" ]]; then
            echo "âŒ ERROR: config/terraform.tfvars not found!"
            exit 1
          fi
          
          echo "âœ… All configuration files present"
          echo "ðŸ“„ Configuration files:"
          ls -la backend.tf locals.tf config/terraform.tfvars

      - name: ðŸ—ï¸ Initialize Terraform
        working-directory: terraform
        run: |
          echo "ðŸ”„ Initializing Terraform for ${{ needs.setup.outputs.environment }} environment..."
          terraform init

      - name: âœ… Validate Terraform
        working-directory: terraform
        run: |
          echo "ðŸ” Validating Terraform configuration..."
          terraform validate

      - name: ðŸ“‹ Plan Terraform Changes
        working-directory: terraform
        run: |
          echo "ðŸ“‹ Creating Terraform plan for ${{ needs.setup.outputs.environment }} environment..."
          terraform plan \
            -var-file=config/terraform.tfvars \
            -out=tfplan-${{ needs.setup.outputs.environment }} \
            -detailed-exitcode || exit_code=$?
          
          if [[ $exit_code -eq 1 ]]; then
            echo "âŒ Terraform plan failed"
            exit 1
          elif [[ $exit_code -eq 2 ]]; then
            echo "âœ… Plan created with changes for ${{ needs.setup.outputs.environment }}"
            echo "has-changes=true" >> $GITHUB_ENV
          else
            echo "âœ… No changes detected for ${{ needs.setup.outputs.environment }}"
            echo "has-changes=false" >> $GITHUB_ENV
          fi

      - name: ðŸ’¾ Upload Plan Artifact
        if: env.has-changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ needs.setup.outputs.environment }}
          path: terraform/tfplan-${{ needs.setup.outputs.environment }}
          retention-days: 7

      - name: ðŸ“¤ Upload Configuration Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-config-${{ needs.setup.outputs.environment }}
          path: |
            terraform/config/
            terraform/backend.tf
            terraform/locals.tf
          retention-days: 1

      - name: ðŸ“ Add Plan Summary to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.setup.outputs.environment }}';
            const hasChanges = '${{ env.has-changes }}' === 'true';
            
            // Determine bucket name directly from environment
            let bucketName;
            switch(environment) {
              case 'prod':
                bucketName = '${{ secrets.PROD_S3_BUCKET }}';
                break;
              default:
                bucketName = '${{ secrets.DEV_S3_BUCKET }}';
                break;
            }
            
            const summary = `## ðŸ—ï¸ Terraform Plan Summary
            
            **Environment**: \`${environment}\` (computed from branch: \`${{ github.ref_name }}\`)
            **Changes**: ${hasChanges ? 'âœ… Changes detected' : 'âœ… No changes'}
            **State Bucket**: \`${bucketName}\`
            
            ${hasChanges ? 'ðŸ“‹ Plan artifact uploaded for review' : ''}
            
            *This environment was automatically computed from the branch name.*
            *Using existing S3 bucket with auto-created DynamoDB table for locking.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });

  apply:
    name: ðŸš€ Apply (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, plan]
    if: needs.setup.outputs.should-apply == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    
    # Debug information about why apply might be skipped
    env:
      DEBUG_EVENT: ${{ github.event_name }}
      DEBUG_BRANCH: ${{ github.ref_name }}
      DEBUG_SHOULD_APPLY: ${{ needs.setup.outputs.should-apply }}
    
    steps:
      - name: ðŸ” Debug Apply Job
        run: |
          echo "ðŸ” Debug Information for Apply Job:"
          echo "Event Type: ${{ env.DEBUG_EVENT }}"
          echo "Branch: ${{ env.DEBUG_BRANCH }}"
          echo "Should Apply: ${{ env.DEBUG_SHOULD_APPLY }}"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          
          if [[ "${{ env.DEBUG_SHOULD_APPLY }}" != "true" ]]; then
            echo "âŒ Apply job was skipped because should-apply is not true"
            echo "This usually means:"
            echo "1. You're not on master or development branch (current: ${{ env.DEBUG_BRANCH }})"
            echo "2. This isn't a manual workflow run with apply action"
            echo ""
            echo "To fix this, either:"
            echo "1. Push to master or development branch"
            echo "2. Use manual workflow dispatch with apply action"
          fi

      - name: ðŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ðŸ“‹ Download Configuration
        uses: actions/download-artifact@v4
        with:
          name: terraform-config-${{ needs.setup.outputs.environment }}
          path: terraform/

      - name: âš™ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: ðŸ” Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: ðŸ—ƒï¸ Ensure DynamoDB Table (State Locking)
        run: |
          ENV="${{ needs.setup.outputs.environment }}"
          TABLE_NAME="${ENV}-${{ env.PROJECT_NAME }}-terraform-locks-${{ secrets.AWS_REGION }}"
          
          echo "ðŸ—ƒï¸ Setting up DynamoDB table for state locking: $TABLE_NAME"
          
          # Create DynamoDB table if it doesn't exist
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null >/dev/null; then
            echo "ðŸ”¨ Creating DynamoDB table: $TABLE_NAME"
            
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 \
              --tags \
                Key=Environment,Value="$ENV" \
                Key=Project,Value="${{ env.PROJECT_NAME }}" \
                Key=Purpose,Value=terraform-locks \
                Key=Repository,Value="${{ github.repository }}"
            
            echo "â³ Waiting for DynamoDB table to become active..."
            aws dynamodb wait table-exists --table-name "$TABLE_NAME"
            echo "âœ… DynamoDB table created and active"
          else
            echo "âœ… DynamoDB table already exists: $TABLE_NAME"
          fi

      - name: ðŸ—ï¸ Initialize Terraform
        working-directory: terraform
        run: |
          echo "ðŸ”„ Initializing Terraform for ${{ needs.setup.outputs.environment }} environment..."
          terraform init

      - name: âœ… Validate Terraform Configuration
        working-directory: terraform
        run: |
          echo "ðŸ” Validating Terraform configuration in apply job..."
          terraform validate

      - name: ðŸ“¥ Download Plan Artifact
        if: github.event.inputs.action != 'destroy'
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ needs.setup.outputs.environment }}
          path: terraform/
        continue-on-error: true

      - name: ðŸš€ Apply or Destroy Infrastructure
        working-directory: terraform
        run: |
          if [[ "${{ github.event.inputs.action }}" == "destroy" ]]; then
            echo "ðŸ—‚ï¸ Destroying infrastructure for ${{ needs.setup.outputs.environment }} environment..."
            terraform destroy -var-file=config/terraform.tfvars -auto-approve
          else
            # Check if plan file exists
            if [[ -f "tfplan-${{ needs.setup.outputs.environment }}" ]]; then
              echo "ðŸš€ Attempting to apply saved plan for ${{ needs.setup.outputs.environment }} environment..."
              if ! terraform apply tfplan-${{ needs.setup.outputs.environment }}; then
                echo "âš ï¸ Saved plan is stale or invalid. Creating new plan..."
                terraform plan -var-file=config/terraform.tfvars -out=tfplan-${{ needs.setup.outputs.environment }}
                echo "ðŸš€ Applying newly created plan..."
                terraform apply tfplan-${{ needs.setup.outputs.environment }}
              fi
            else
              echo "ðŸ“‹ No saved plan found. Creating new plan and applying..."
              terraform plan -var-file=config/terraform.tfvars -out=tfplan-${{ needs.setup.outputs.environment }}
              terraform apply tfplan-${{ needs.setup.outputs.environment }}
            fi
          fi

      - name: ðŸ“Š Show Infrastructure Outputs
        if: github.event.inputs.action != 'destroy'
        working-directory: terraform
        run: |
          echo "ðŸ“Š Infrastructure outputs for ${{ needs.setup.outputs.environment }}:"
          terraform output -json

      - name: ðŸ“ Deployment Summary
        run: |
          # Determine bucket name for summary
          ENV="${{ needs.setup.outputs.environment }}"
          case "$ENV" in
            prod)
              BUCKET_NAME="${{ secrets.PROD_S3_BUCKET }}"
              ;;
            *)
              BUCKET_NAME="${{ secrets.DEV_S3_BUCKET }}"
              ;;
          esac
          
          # Check if plan file was used
          if [[ -f "terraform/tfplan-${{ needs.setup.outputs.environment }}" ]]; then
            PLAN_SOURCE="âœ… Used saved plan from plan job"
          else
            PLAN_SOURCE="ðŸ“‹ Generated new plan (no saved plan available)"
          fi
          
          echo "## ðŸŽ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }} (computed from branch: ${{ github.ref_name }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: ${{ github.event.inputs.action || 'apply' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- **State Bucket**: $BUCKET_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Plan Source**: $PLAN_SOURCE" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ 100% Pipeline-Native:" >> $GITHUB_STEP_SUMMARY
          echo "- Branch: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: \`${{ needs.setup.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Using existing S3 bucket with auto-created DynamoDB table" >> $GITHUB_STEP_SUMMARY
          echo "- Zero external scripts used" >> $GITHUB_STEP_SUMMARY
          echo "- All configuration generated dynamically in pipeline" >> $GITHUB_STEP_SUMMARY 