name: Provision AWS Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: string
    secrets:
      AWS_REGION:
        required: true
      AWS_ROLE_NAME:
        required: true
      AWS_ACCOUNT_ID:
        required: true
      DEV_S3_BUCKET:
        required: true
      PROD_S3_BUCKET:
        required: true
      DEV_CLOUDFRONT_ID:
        required: true
      PROD_CLOUDFRONT_ID:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  deploy-cdk:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ROLE_NAME: ${{ secrets.AWS_ROLE_NAME }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      NODE_ENV: ${{ inputs.environment }}
      APP_NAME: 'octonius'
      DOMAIN_NAME: ${{ vars.DOMAIN_NAME || 'dev.octonius.com' }}
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install

      - name: Install CDK
        run: |
          npm install -g aws-cdk

      - name: Preprocess policy files
        run: |
          for policy_file in cdk/*-policy.json; do
            sed -i "s/\${AWS_ACCOUNT_ID}/${{ env.AWS_ACCOUNT_ID }}/g" "$policy_file"
            sed -i "s/\${AWS_REGION}/${{ env.AWS_REGION }}/g" "$policy_file"
            sed -i "s/\${NODE_ENV}/${{ env.NODE_ENV }}/g" "$policy_file"
            sed -i "s/\${DEV_S3_BUCKET}/${{ secrets.DEV_S3_BUCKET }}/g" "$policy_file"
            sed -i "s/\${PROD_S3_BUCKET}/${{ secrets.PROD_S3_BUCKET }}/g" "$policy_file"
          done

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ env.AWS_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build
        run: npm run build

      - name: Create/Update IAM Policy for CDK CloudFormation Execution
        run: |
          create_or_update_policy() {
            local policy_name=$1
            local policy_file=$2
            local description=$3
            local account_id="${{ env.AWS_ACCOUNT_ID }}"
            local expected_policy_arn="arn:aws:iam::${account_id}:policy/${policy_name}"

            if aws iam get-policy --policy-arn ${expected_policy_arn} > /dev/null 2>&1; then
              POLICY_VERSIONS_JSON=$(aws iam list-policy-versions --policy-arn "${expected_policy_arn}")
              VERSION_COUNT=$(echo "${POLICY_VERSIONS_JSON}" | jq '.Versions | length')

              if [ "${VERSION_COUNT}" -ge 5 ]; then
                OLDEST_NON_DEFAULT_VERSION_ID=$(echo "${POLICY_VERSIONS_JSON}" | \
                  jq -r '.Versions | sort_by(.CreateDate) | map(select(.IsDefaultVersion == false)) | .[0].VersionId // null')

                if [ -n "${OLDEST_NON_DEFAULT_VERSION_ID}" ] && [ "${OLDEST_NON_DEFAULT_VERSION_ID}" != "null" ] && [ "${OLDEST_NON_DEFAULT_VERSION_ID}" != "" ]; then
                  aws iam delete-policy-version --policy-arn "${expected_policy_arn}" --version-id "${OLDEST_NON_DEFAULT_VERSION_ID}"
                fi
              fi

              aws iam create-policy-version --policy-arn "${expected_policy_arn}" --policy-document file://${policy_file} --set-as-default
            else
              aws iam create-policy --policy-name ${policy_name} --policy-document file://${policy_file} --description "${description}"
            fi
          }

          create_or_update_policy "${{ inputs.environment }}-cdk-base-policy" "cdk/cdk-base-policy.json" "Base policy for CDK operations"
          create_or_update_policy "${{ inputs.environment }}-cdk-cloudformation-policy" "cdk/cdk-cloudformation-policy.json" "CloudFormation policy for CDK operations"
          create_or_update_policy "${{ inputs.environment }}-cdk-s3-policy" "cdk/cdk-s3-policy.json" "S3 policy for CDK operations"
          create_or_update_policy "${{ inputs.environment }}-cdk-iam-policy" "cdk/cdk-iam-policy.json" "IAM policy for CDK operations"
          create_or_update_policy "${{ inputs.environment }}-cdk-services-policy" "cdk/cdk-services-policy.json" "Services policy for CDK operations"
          create_or_update_policy "${{ inputs.environment }}-cdk-network-policy" "cdk/cdk-network-policy.json" "Network policy for CDK operations"

          # Construct the actual policy ARNs
          ACCOUNT_ID="${{ env.AWS_ACCOUNT_ID }}"
          BASE_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-base-policy"
          CLOUDFORMATION_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-cloudformation-policy"
          S3_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-s3-policy"
          IAM_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-iam-policy"
          SERVICES_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-services-policy"
          NETWORK_POLICY_ARN="arn:aws:iam::${ACCOUNT_ID}:policy/${{ inputs.environment }}-cdk-network-policy"

          echo "AWS_CDK_POLICY_ARN_FROM_FILE=${BASE_POLICY_ARN},${CLOUDFORMATION_POLICY_ARN},${S3_POLICY_ARN},${IAM_POLICY_ARN},${SERVICES_POLICY_ARN},${NETWORK_POLICY_ARN}" >> $GITHUB_ENV
          
          # Debug: Show the constructed policy ARNs
          echo "Constructed policy ARNs: ${BASE_POLICY_ARN},${CLOUDFORMATION_POLICY_ARN},${S3_POLICY_ARN},${IAM_POLICY_ARN},${SERVICES_POLICY_ARN},${NETWORK_POLICY_ARN}"
        shell: bash

      - name: Bootstrap CDK
        run: |
          echo "Using policy ARNs: ${AWS_CDK_POLICY_ARN_FROM_FILE}"
        
          if [ "${{ inputs.environment }}" = "dev" ]; then
            BOOTSTRAP_BUCKET="${{ secrets.DEV_S3_BUCKET }}"
          else
            BOOTSTRAP_BUCKET="${{ secrets.PROD_S3_BUCKET }}"
          fi
          
          echo "Using bootstrap bucket: ${BOOTSTRAP_BUCKET}"
          
          # Clean up any failed CDKToolkit stack first
          echo "Checking for existing CDKToolkit stack..."
          EXISTING_STACK=$(aws cloudformation describe-stacks --stack-name CDKToolkit --region ${{ env.AWS_REGION }} --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NONE")
          
          if [[ "$EXISTING_STACK" == "ROLLBACK_COMPLETE" || "$EXISTING_STACK" == "CREATE_FAILED" || "$EXISTING_STACK" == "UPDATE_ROLLBACK_COMPLETE" ]]; then
            echo "Found failed CDKToolkit stack in state: $EXISTING_STACK. Deleting it..."
            aws cloudformation delete-stack --stack-name CDKToolkit --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete --stack-name CDKToolkit --region ${{ env.AWS_REGION }}
            echo "CDKToolkit stack deleted successfully"
          elif [[ "$EXISTING_STACK" != "NONE" ]]; then
            echo "CDKToolkit stack exists in state: $EXISTING_STACK"
          fi
          
          # Bootstrap with proper error handling and simplified tags
          echo "Starting CDK bootstrap..."
          
          # Use simplified tags to avoid ECR tag validation issues
          SIMPLE_TAGS="Environment=${{ inputs.environment }},Project=${{ env.APP_NAME }},ManagedBy=CDK,Owner=Octonius Team"
          
          # Try bootstrap with existing bucket first
          if aws s3 ls "s3://${BOOTSTRAP_BUCKET}" >/dev/null 2>&1; then
            echo "Bucket ${BOOTSTRAP_BUCKET} exists, bootstrapping with existing bucket..."
            
            cdk bootstrap \
              --cloudformation-execution-policies "${AWS_CDK_POLICY_ARN_FROM_FILE}" \
              --bootstrap-bucket-name "${BOOTSTRAP_BUCKET}" \
              --bootstrap-kms-key-id alias/aws/s3 \
              --tags "${SIMPLE_TAGS}" \
              --force || {
                
                echo "Bootstrap with existing bucket failed. Trying without specifying bucket name..."
                
                # Fallback: Let CDK create its own bucket but clean up the failed attempt first
                if aws cloudformation describe-stacks --stack-name CDKToolkit --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
                  echo "Cleaning up failed bootstrap attempt..."
                  aws cloudformation delete-stack --stack-name CDKToolkit --region ${{ env.AWS_REGION }}
                  aws cloudformation wait stack-delete-complete --stack-name CDKToolkit --region ${{ env.AWS_REGION }}
                fi
                
                # Bootstrap without specifying bucket (let CDK create one)
                cdk bootstrap \
                  --cloudformation-execution-policies "${AWS_CDK_POLICY_ARN_FROM_FILE}" \
                  --bootstrap-kms-key-id alias/aws/s3 \
                  --tags "${SIMPLE_TAGS}"
                  
                # Get the auto-created bucket name for tracking
                BOOTSTRAP_BUCKET=$(aws cloudformation describe-stack-resources \
                  --stack-name CDKToolkit \
                  --logical-resource-id StagingBucket \
                  --query 'StackResources[0].PhysicalResourceId' \
                  --output text)
                  
                echo "CDK created bucket: ${BOOTSTRAP_BUCKET}"
              }
          else
            echo "Bucket ${BOOTSTRAP_BUCKET} not found. Using CDK auto-generated bucket..."
            
            cdk bootstrap \
              --cloudformation-execution-policies "${AWS_CDK_POLICY_ARN_FROM_FILE}" \
              --bootstrap-kms-key-id alias/aws/s3 \
              --tags "${SIMPLE_TAGS}"
              
            # Get the auto-created bucket name
            BOOTSTRAP_BUCKET=$(aws cloudformation describe-stack-resources \
              --stack-name CDKToolkit \
              --logical-resource-id StagingBucket \
              --query 'StackResources[0].PhysicalResourceId' \
              --output text)
              
            echo "CDK created bucket: ${BOOTSTRAP_BUCKET}"
          fi
          
          # Export the actual bucket being used for deployment tracking
          echo "BOOTSTRAP_BUCKET=${BOOTSTRAP_BUCKET}" >> $GITHUB_ENV
          echo "Bootstrap completed successfully with bucket: ${BOOTSTRAP_BUCKET}"

      - name: Create Deployment Manifest
        run: |
          # Create deployment tracking manifest
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          
          # Use the bootstrap bucket that was determined/created in the previous step
          echo "Using bootstrap bucket from previous step: ${BOOTSTRAP_BUCKET}"
          
          # Create deployment manifest
          cat > deployment-manifest.json << EOF
          {
            "deploymentId": "${DEPLOYMENT_ID}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "environment": "${{ inputs.environment }}",
            "gitCommit": "${{ github.sha }}",
            "gitRef": "${{ github.ref }}",
            "gitActor": "${{ github.actor }}",
            "runId": "${{ github.run_id }}",
            "runNumber": "${{ github.run_number }}",
            "workflowName": "${{ github.workflow }}",
            "cdkVersion": "$(cdk --version)",
            "nodeVersion": "$(node --version)",
            "awsRegion": "${{ env.AWS_REGION }}",
            "awsAccount": "${{ env.AWS_ACCOUNT_ID }}",
            "appName": "${{ env.APP_NAME }}",
            "bootstrapBucket": "${BOOTSTRAP_BUCKET}",
            "status": "deploying"
          }
          EOF
          
          # Upload deployment manifest to bootstrap bucket
          aws s3 cp deployment-manifest.json "s3://${BOOTSTRAP_BUCKET}/deployments/${DEPLOYMENT_ID}/manifest.json"
          
          # Also create a latest deployment pointer
          aws s3 cp deployment-manifest.json "s3://${BOOTSTRAP_BUCKET}/deployments/latest-${{ inputs.environment }}.json"
          
          # Export deployment ID for next steps
          echo "DEPLOYMENT_ID=${DEPLOYMENT_ID}" >> $GITHUB_ENV
          
          echo "Created deployment manifest: ${DEPLOYMENT_ID}"

      - name: CDK Deploy
        env:
          NODE_ENV: ${{ inputs.environment }}
        run: |
          cdk deploy --all --require-approval never 

      - name: Update Deployment Status
        if: always()
        run: |
          # Capture deployment outcome
          if [ "${{ job.status }}" = "success" ]; then
            DEPLOYMENT_STATUS="success"
          else
            DEPLOYMENT_STATUS="failed"
          fi
          
          # Get list of deployed stacks
          DEPLOYED_STACKS=$(aws cloudformation list-stacks --region ${{ env.AWS_REGION }} --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE --query 'StackSummaries[?contains(StackName, `${{ env.APP_NAME }}`)].[StackName]' --output text | tr '\n' ',' | sed 's/,$//')
          
          # Create final deployment manifest
          cat > final-deployment-manifest.json << EOF
          {
            "deploymentId": "${DEPLOYMENT_ID}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "completedAt": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "environment": "${{ inputs.environment }}",
            "gitCommit": "${{ github.sha }}",
            "gitRef": "${{ github.ref }}",
            "gitActor": "${{ github.actor }}",
            "runId": "${{ github.run_id }}",
            "runNumber": "${{ github.run_number }}",
            "workflowName": "${{ github.workflow }}",
            "cdkVersion": "$(cdk --version)",
            "nodeVersion": "$(node --version)",
            "awsRegion": "${{ env.AWS_REGION }}",
            "awsAccount": "${{ env.AWS_ACCOUNT_ID }}",
            "appName": "${{ env.APP_NAME }}",
            "bootstrapBucket": "${BOOTSTRAP_BUCKET}",
            "status": "${DEPLOYMENT_STATUS}",
            "deployedStacks": "${DEPLOYED_STACKS}",
            "duration": "$(echo $(($(date +%s) - $(date -d '${{ job.started_at }}' +%s))) seconds"
          }
          EOF
          
          # Upload final manifest
          aws s3 cp final-deployment-manifest.json "s3://${BOOTSTRAP_BUCKET}/deployments/${DEPLOYMENT_ID}/final-manifest.json"
          
          # Update latest pointer if successful
          if [ "${DEPLOYMENT_STATUS}" = "success" ]; then
            aws s3 cp final-deployment-manifest.json "s3://${BOOTSTRAP_BUCKET}/deployments/latest-${{ inputs.environment }}-success.json"
          fi
          
          # Create deployment history entry
          aws s3 cp final-deployment-manifest.json "s3://${BOOTSTRAP_BUCKET}/deployments/history/$(date +%Y/%m/%d)/${DEPLOYMENT_ID}.json"
          
          echo "Deployment tracking completed: ${DEPLOYMENT_STATUS}" 