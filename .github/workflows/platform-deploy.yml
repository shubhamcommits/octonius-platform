name: üöÄ Platform Deployment

on:
  push:
    branches:
      - master
      - development
      - 'feature/*'
      - 'hotfix/*'
    paths:
      - 'services/**'
      - 'terraform/**'
      - '.github/workflows/**'
      - 'src/**'
      - 'server.ts'
  # pull_request:
  #   branches:
  #     - master
  #     - development
  #   paths:
  #     - 'services/**'
  #     - 'terraform/**'
  #     - '.github/workflows/**'
  #     - 'src/**'
  #     - 'server.ts'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - prod
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - destroy
      skip_validation:
        description: 'Skip validation steps'
        required: false
        type: boolean
        default: false

# Prevent parallel deployments of the same environment
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Define all environment variables at the top level
env:
  # Terraform Configuration
  TF_VERSION: '1.7.4'
  REPOSITORY_NAME: 'octonius'
  OWNER: 'Octonius-Team'

  # AWS Configuration
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_KEY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }} 
  
  # S3 Bucket Configuration
  PROD_S3_BUCKET: ${{ secrets.PROD_S3_BUCKET }}
  DEV_S3_BUCKET: ${{ secrets.DEV_S3_BUCKET }}
  
  # Node.js Configuration
  NODE_VERSION: '20.x'

# Set minimum required permissions
permissions:
  contents: read
  id-token: write
  pull-requests: write

jobs:
  validate-env:
    name: "üîç Validate All Environment Variables"
    runs-on: ubuntu-latest
    steps:
      - name: Validate Required Environment Variables
        run: |
          REQUIRED_VARS="TF_VERSION,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION,AWS_ACCOUNT_ID,PROD_S3_BUCKET,DEV_S3_BUCKET,NODE_VERSION,REPOSITORY_NAME,OWNER"
          IFS=',' read -ra VARS <<< "$REQUIRED_VARS"
          MISSING=()
          for var in "${VARS[@]}"; do
            if [[ -z "${!var}" ]]; then
              MISSING+=("$var")
            fi
          done
          if [ ${#MISSING[@]} -ne 0 ]; then
            echo "‚ùå Missing required variables: ${MISSING[*]}"
            exit 1
          else
            echo "‚úÖ All required variables are set."
          fi
  determine-action:
    name: ü§î Determine Action
    needs: validate-env
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      action: ${{ steps.action.outputs.pipeline_action }}
    steps:
      - name: üéØ Determine Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.head_ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi
          if [[ -n "${{ github.event.inputs.environment }}" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "$BRANCH" in
              master)
                ENV="prod";;
              development|dev)
                ENV="dev";;
              feature/*)
                ENV=$(echo "$BRANCH" | sed 's|feature/|feature-|g' | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]');;
              hotfix/*)
                ENV=$(echo "$BRANCH" | sed 's|hotfix/|hotfix-|g' | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]');;
              *)
                ENV=$(echo "$BRANCH" | tr '/' '-' | tr '_' '-' | tr '[:upper:]' '[:lower:]');;
            esac
          fi
          echo "Branch: $BRANCH"
          echo "Environment: $ENV"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
      - name: ‚öñÔ∏è Determine Pipeline Action
        id: action
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.action }}" ]]; then
            ACTION="${{ github.event.inputs.action }}"
          else
            ACTION="deploy"
          fi
          echo "Pipeline action: $ACTION"
          echo "pipeline_action=$ACTION" >> $GITHUB_OUTPUT

  docker-image-build:
    name: üê≥ Docker Image Build
    needs: [validate-env, determine-action]
    runs-on: ubuntu-latest
    env:
      PIPELINE_ACTION: ${{ needs.determine-action.outputs.action }}
    steps:
      - name: ‚ÑπÔ∏è Skip Docker build for destroy
        if: ${{ env.PIPELINE_ACTION == 'destroy' }}
        run: echo "Destroy action detected; skipping Docker image build."
      - name: üì• Checkout Code
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/checkout@v4
      - name: üîê Configure AWS Credentials
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: üîë Login to Amazon ECR
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: üèóÔ∏è Build and Push Web Image
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        id: web-image
        run: |
          IMAGE_TAG="${GITHUB_SHA}"
          ECR_REGISTRY="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_REPOSITORY="${{ needs.determine-action.outputs.environment }}/${{ env.REPOSITORY_NAME }}"
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.determine-action.outputs.environment }} \
            -f Dockerfile \
            --build-arg NODE_ENV=${{ needs.determine-action.outputs.environment }} \
            .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest-${{ needs.determine-action.outputs.environment }}

  infra:
    name: üèóÔ∏è Infrastructure Management
    needs: [validate-env, docker-image-build, determine-action]
    runs-on: ubuntu-latest
    outputs:
      web_cloudfront_distribution_id: ${{ steps.extract.outputs.WEB_CLOUDFRONT_DISTRIBUTION_ID }}
    env:
      PIPELINE_ACTION: ${{ needs.determine-action.outputs.action }}
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
      - name: ‚öôÔ∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: üóÉÔ∏è Create DynamoDB Table (State Locking)
        run: |
          ENV="${{ needs.determine-action.outputs.environment }}"
          TABLE_NAME="$ENV-${{ env.REPOSITORY_NAME }}-terraform-locks-${{ env.AWS_REGION }}"
          echo "üóÉÔ∏è Setting up DynamoDB table for state locking: $TABLE_NAME"
          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null >/dev/null; then
            echo "üî® Creating DynamoDB table: $TABLE_NAME"
            aws dynamodb create-table \
              --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 \
              --tags \
                Key=Environment,Value="$ENV" \
                Key=Project,Value="${{ env.REPOSITORY_NAME }}" \
                Key=Purpose,Value=terraform-locks \
                Key=Repository,Value="${{ github.repository }}"
            echo "‚è≥ Waiting for DynamoDB table to become active..."
            aws dynamodb wait table-exists --table-name "$TABLE_NAME"
            echo "‚úÖ DynamoDB table created and active"
          else
            echo "‚úÖ DynamoDB table already exists: $TABLE_NAME"
          fi
      - name: üìù Generate Locals Configuration
        working-directory: terraform
        run: |
          ENV="${{ needs.determine-action.outputs.environment }}"
          ACCOUNT_ID="${{ env.AWS_ACCOUNT_ID }}"
          REGION="${{ env.AWS_REGION }}"
          ACTOR="${{ github.actor }}"
          OWNER="${{ env.OWNER }}"
          DATE="$(date -u +"%Y-%m-%d")"
          cat > locals.tf <<EOF
          locals {
            environment  = "$ENV"
            project_name = "${{ env.REPOSITORY_NAME }}"
            aws_region   = "$REGION"
            account_id   = "$ACCOUNT_ID"
            name_prefix  = "\${local.environment}-\${local.project_name}"
            common_tags = {
              Environment = local.environment
              Project     = local.project_name
              ManagedBy   = "terraform"
              Repository  = "${{ github.repository }}"
              Branch      = local.environment
              Account     = local.account_id
              Region      = local.aws_region
              CreatedBy   = "$ACTOR"
              Owner       = "$OWNER"
            }
          }
          EOF
      - name: üìù Generate Variables Configuration
        working-directory: terraform
        run: |
          mkdir -p config
          ENV="${{ needs.determine-action.outputs.environment }}"
          case "$ENV" in
            prod)
              VPC_CIDR="10.0.0.0/16"
              PUBLIC_SUBNETS='["10.0.1.0/24", "10.0.2.0/24"]'
              PRIVATE_SUBNETS='["10.0.10.0/24", "10.0.20.0/24"]'
              ;;
            dev)
              VPC_CIDR="10.1.0.0/16"
              PUBLIC_SUBNETS='["10.1.1.0/24", "10.1.2.0/24"]'
              PRIVATE_SUBNETS='["10.1.10.0/24", "10.1.20.0/24"]'
              ;;
            *)
              ENV_HASH=$(echo -n "$ENV" | md5sum | cut -c1-2)
              SECOND_OCTET=$((0x$ENV_HASH % 240 + 10))
              VPC_CIDR="10.${SECOND_OCTET}.0.0/16"
              PUBLIC_SUBNETS="[\"10.${SECOND_OCTET}.1.0/24\", \"10.${SECOND_OCTET}.2.0/24\"]"
              PRIVATE_SUBNETS="[\"10.${SECOND_OCTET}.10.0/24\", \"10.${SECOND_OCTET}.20.0/24\"]"
              ;;
          esac
          if [[ "${PIPELINE_ACTION}" == "destroy" ]]; then
            FORCE_SKIP_FINAL_SNAPSHOT=true
          else
            FORCE_SKIP_FINAL_SNAPSHOT=false
          fi
          
          # Define whitelisted IPs directly in the pipeline
          # Update this list as needed when IPs change
          cat > config/ip_whitelist.tfvars <<EOF
          whitelisted_ips = {
            "shubham-macbook" = {
              cidr        = "183.83.153.50/32"
              description = "Shubham Macbook IP"
            },
            "shubham-macbook-vpn" = {
              cidr        = "165.225.0.0/16"
              description = "Shubham Macbook VPN IP"
            },
            "shubham-macbook-new-vpn" = {
              cidr        = "49.205.0.0/16"
              description = "Shubham Macbook New VPN IP"
            }
          }
          EOF
          
          cat > config/terraform.tfvars <<EOF
          environment  = "$ENV"
          project_name = "${{ env.REPOSITORY_NAME }}"
          aws_region   = "${{ env.AWS_REGION }}"
          vpc_cidr           = "$VPC_CIDR"
          public_subnets     = $PUBLIC_SUBNETS
          private_subnets    = $PRIVATE_SUBNETS
          image_tag          = "${GITHUB_SHA}"
          bastion_key_name   = "$ENV-${{ env.REPOSITORY_NAME }}-bastion"
          force_destroy_skip_final_snapshot = $FORCE_SKIP_FINAL_SNAPSHOT
          
          # Whitelisted IPs for bastion host access
          whitelisted_ips = {
            "shubham-macbook" = {
              cidr        = "183.83.153.50/32"
              description = "Shubham Macbook IP"
            },
            "shubham-macbook-vpn" = {
              cidr        = "165.225.0.0/16"
              description = "Shubham Macbook VPN IP"
            },
            "shubham-macbook-new-vpn" = {
              cidr        = "49.205.0.0/16"
              description = "Shubham Macbook New VPN IP"
            }
          }
          EOF

      - name: üìù Show terraform.tfvars
        run: cat terraform/config/terraform.tfvars
      - name: üìù Generate Terraform Configuration
        run: |
          mkdir -p terraform/config
          case "${{ needs.determine-action.outputs.environment }}" in
            prod)
              BUCKET_NAME="${{ env.PROD_S3_BUCKET }}";;
            *)
              BUCKET_NAME="${{ env.DEV_S3_BUCKET }}";;
          esac
          cat > terraform/backend.tf << EOF
          terraform {
            backend "s3" {
              bucket         = "$BUCKET_NAME"
              key            = "terraform/${{ needs.determine-action.outputs.environment }}/terraform.tfstate"
              region         = "${{ env.AWS_REGION }}"
              encrypt        = true
              dynamodb_table = "${{ needs.determine-action.outputs.environment }}-${{ env.REPOSITORY_NAME }}-terraform-locks-${{ env.AWS_REGION }}"
            }
          }
          EOF
      - name: üèóÔ∏è Initialize Terraform
        working-directory: terraform
        run: terraform init
      - name: ‚úÖ Validate Terraform
        working-directory: terraform
        run: terraform validate
      - name: üìã Plan Terraform Changes
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        working-directory: terraform
        run: |
          terraform plan \
            -var-file=config/terraform.tfvars \
            -var-file=config/ip_whitelist.tfvars \
            -out=tfplan-${{ needs.determine-action.outputs.environment }} \
            -detailed-exitcode || exit_code=$?
          if [[ $exit_code -eq 1 ]]; then
            echo "‚ùå Terraform plan failed"
            exit 1
          elif [[ $exit_code -eq 2 ]]; then
            echo "‚úÖ Plan created with changes for ${{ needs.determine-action.outputs.environment }}"
            echo "has-changes=true" >> $GITHUB_ENV
          else
            echo "‚úÖ No changes detected for ${{ needs.determine-action.outputs.environment }}"
            echo "has-changes=false" >> $GITHUB_ENV
          fi
      - name: üîç Check App Runner Status
        if: ${{ env.PIPELINE_ACTION != 'destroy' && env.has-changes == 'true' }}
        working-directory: terraform
        run: |
          # Try to get the App Runner service ARN from Terraform state
          SERVICE_ARN=$(terraform output -raw app_runner_service_arn 2>/dev/null || echo "")
          
          if [ -n "$SERVICE_ARN" ]; then
            echo "üîç Checking App Runner service status..."
            echo "Service ARN: $SERVICE_ARN"
            
            # Check service status
            STATUS=$(aws apprunner describe-service \
              --service-arn "$SERVICE_ARN" \
              --query 'Service.Status' \
              --output text 2>/dev/null || echo "UNKNOWN")
            
            echo "Current status: $STATUS"
            
            if [ "$STATUS" = "OPERATION_IN_PROGRESS" ]; then
              echo "‚ö†Ô∏è  App Runner is currently in OPERATION_IN_PROGRESS state"
              echo "‚è≥ Waiting for operation to complete (max 10 minutes)..."
              
              WAIT_TIME=0
              MAX_WAIT=600  # 10 minutes
              
              while [ "$STATUS" = "OPERATION_IN_PROGRESS" ] && [ $WAIT_TIME -lt $MAX_WAIT ]; do
                sleep 30
                WAIT_TIME=$((WAIT_TIME + 30))
                STATUS=$(aws apprunner describe-service \
                  --service-arn "$SERVICE_ARN" \
                  --query 'Service.Status' \
                  --output text 2>/dev/null || echo "UNKNOWN")
                echo "Status after ${WAIT_TIME}s: $STATUS"
              done
              
              if [ "$STATUS" = "OPERATION_IN_PROGRESS" ]; then
                echo "‚ùå App Runner is still in OPERATION_IN_PROGRESS after 10 minutes"
                echo "You may need to wait longer or check the AWS Console"
                exit 1
              fi
            fi
            
            echo "‚úÖ App Runner is in $STATUS state, ready to proceed"
          else
            echo "‚ÑπÔ∏è  No existing App Runner service found or unable to retrieve ARN"
          fi
      - name: üöÄ Apply Infrastructure
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        working-directory: terraform
        run: |
          # Function to apply Terraform with retries for App Runner
          apply_with_retry() {
            local max_attempts=3
            local attempt=1
            local wait_time=60
            
            # Enable pipefail to capture exit code from terraform, not tee
            set -o pipefail
            
            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Terraform apply attempt $attempt of $max_attempts"
              
              exit_code=0
              if [[ -f "tfplan-${{ needs.determine-action.outputs.environment }}" ]]; then
                echo "üöÄ Applying saved plan..."
                terraform apply tfplan-${{ needs.determine-action.outputs.environment }} 2>&1 | tee apply.log || exit_code=$?
              else
                echo "üìã No saved plan found. Creating new plan and applying..."
                terraform plan -var-file=config/terraform.tfvars -var-file=config/ip_whitelist.tfvars -out=tfplan-${{ needs.determine-action.outputs.environment }}
                terraform apply tfplan-${{ needs.determine-action.outputs.environment }} 2>&1 | tee apply.log || exit_code=$?
              fi
              
              # Check if the error is due to App Runner being in OPERATION_IN_PROGRESS
              if grep -q "OPERATION_IN_PROGRESS" apply.log; then
                if [ $attempt -lt $max_attempts ]; then
                  echo "‚ö†Ô∏è  App Runner is in OPERATION_IN_PROGRESS state. Waiting $wait_time seconds before retry..."
                  sleep $wait_time
                  # Increase wait time for next attempt
                  wait_time=$((wait_time * 2))
                  attempt=$((attempt + 1))
                  # Recreate the plan for the next attempt
                  rm -f tfplan-${{ needs.determine-action.outputs.environment }}
                else
                  echo "‚ùå Max retries reached. App Runner is still in OPERATION_IN_PROGRESS state."
                  exit 1
                fi
              elif [ "${exit_code}" -eq 0 ]; then
                echo "‚úÖ Terraform apply successful!"
                break
              else
                echo "‚ùå Terraform apply failed with exit code: ${exit_code}"
                exit ${exit_code}
              fi
            done
          }
          
          # Execute the apply with retry logic
          apply_with_retry
      - name: üóëÔ∏è Destroy Infrastructure
        if: ${{ env.PIPELINE_ACTION == 'destroy' }}
        env:
          WEB_BUCKET: ${{ needs.determine-action.outputs.environment }}-${{ env.REPOSITORY_NAME }}-web-deployment-bucket-${{ env.AWS_REGION }}
          ECR_REPOSITORY: ${{ needs.determine-action.outputs.environment }}/${{ env.REPOSITORY_NAME }}
        working-directory: terraform
        run: |
          set -euo pipefail

          empty_versioned_bucket() {
            local bucket="$1"
            if ! aws s3api head-bucket --bucket "$bucket" >/dev/null 2>&1; then
              echo "Bucket $bucket does not exist, skipping cleanup."
              return
            fi

            echo "üßπ Emptying bucket: $bucket"
            local tmp_file
            tmp_file=$(mktemp)
            while true; do
              aws s3api list-object-versions --bucket "$bucket" > "$tmp_file"
              local count
              count=$(jq '[.Versions[]?, .DeleteMarkers[]?] | length' "$tmp_file")
              if [ "$count" -eq 0 ]; then
                echo "Bucket $bucket is empty."
                break
              fi
              jq '{Objects: ((.Versions // []) + (.DeleteMarkers // [])) | map({Key, VersionId})}' "$tmp_file" > delete.json
              aws s3api delete-objects --bucket "$bucket" --delete file://delete.json >/dev/null
              rm -f delete.json
            done
            rm -f "$tmp_file"
          }

          empty_ecr_repository() {
            local repository="$1"
            if ! aws ecr describe-repositories --repository-names "$repository" >/dev/null 2>&1; then
              echo "Repository $repository does not exist, skipping cleanup."
              return
            fi

            echo "üóëÔ∏è Removing images from ECR repository: $repository"
            while true; do
              local images_json
              images_json=$(aws ecr list-images --repository-name "$repository" --filter tagStatus=ANY --max-items 1000)
              local image_count
              image_count=$(echo "$images_json" | jq '.imageIds | length')
              if [ "$image_count" -eq 0 ]; then
                echo "Repository $repository is empty."
                break
              fi
              local ids
              ids=$(echo "$images_json" | jq -c '.imageIds')
              aws ecr batch-delete-image --repository-name "$repository" --image-ids "$ids" >/dev/null
            done
          }

          empty_versioned_bucket "$WEB_BUCKET"
          empty_ecr_repository "$ECR_REPOSITORY"

          terraform destroy \
            -var-file=config/terraform.tfvars \
            -var-file=config/ip_whitelist.tfvars \
            -var force_destroy_skip_final_snapshot=true \
            -auto-approve
      - name: üìä Extract Outputs
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        id: extract
        working-directory: terraform
        run: |
          echo "WEB_CLOUDFRONT_DISTRIBUTION_ID=$(terraform output -raw web_cloudfront_distribution_id)" >> $GITHUB_OUTPUT

  angular-build:
    name: üèóÔ∏è Angular Build
    needs: [validate-env, determine-action]
    runs-on: ubuntu-latest
    env:
      PIPELINE_ACTION: ${{ needs.determine-action.outputs.action }}
    steps:
      - name: ‚ÑπÔ∏è Skip Angular build for destroy
        if: ${{ env.PIPELINE_ACTION == 'destroy' }}
        run: echo "Destroy action detected; skipping Angular build."
      - name: üì• Checkout Code
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/checkout@v4
      - name: ‚öôÔ∏è Setup Node.js
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: üì¶ Install Dependencies
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        working-directory: services/octonius-web
        run: npm install
      - name: üèóÔ∏è Build Angular App
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        id: build
        working-directory: services/octonius-web
        run: |
          if [[ "${{ needs.determine-action.outputs.environment }}" == "prod" ]]; then
            echo "Using production configuration"
            export NODE_ENV=production
            npm run build -- --configuration production
          else
            echo "Using development configuration"
            export NODE_ENV=development
            npm run build -- --configuration development
          fi
          echo "dist_path=services/octonius-web/dist/octonius-web" >> $GITHUB_OUTPUT
      - name: üì¶ Upload Build Artifact
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/upload-artifact@v4
        with:
          name: angular-build-${{ needs.determine-action.outputs.environment }}
          path: services/octonius-web/dist/octonius-web
          retention-days: 1

  deploy-web:
    name: üöÄ Deploy Web Assets
    needs: [validate-env, infra, determine-action, angular-build]
    runs-on: ubuntu-latest
    env:
      PIPELINE_ACTION: ${{ needs.determine-action.outputs.action }}
    steps:
      - name: ‚ÑπÔ∏è Skip web deployment for destroy
        if: ${{ env.PIPELINE_ACTION == 'destroy' }}
        run: echo "Destroy action detected; skipping web deployment."
      - name: üì• Checkout Code
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/checkout@v4
      - name: üîê Configure AWS Credentials
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: üì¶ Download Build Artifacts
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        uses: actions/download-artifact@v4
        with:
          name: angular-build-${{ needs.determine-action.outputs.environment }}
          path: dist
      - name: üöÄ Deploy to S3 (Versioned)
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        run: |
          BUILD_VERSION="$(date +'%Y%m%d%H%M%S')-${GITHUB_SHA:0:7}"
          echo "Build version: $BUILD_VERSION"
          BUCKET_NAME="${{ needs.determine-action.outputs.environment }}-${{ env.REPOSITORY_NAME }}-web-deployment-bucket-${{ env.AWS_REGION }}"
          # Versioned build
          aws s3 sync dist/ s3://$BUCKET_NAME/builds/$BUILD_VERSION/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html" \
            --exclude "assets/*"
          aws s3 sync dist/ s3://$BUCKET_NAME/builds/$BUILD_VERSION/ \
            --delete \
            --cache-control "no-cache, no-store, must-revalidate" \
            --include "*.html"
          if [ -d dist/assets ]; then
            aws s3 sync dist/assets/ s3://$BUCKET_NAME/builds/$BUILD_VERSION/assets/ \
              --delete \
              --cache-control "public, max-age=3600"
          fi
          # Latest build
          aws s3 sync dist/ s3://$BUCKET_NAME/latest/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "*.html" \
            --exclude "assets/*"
          aws s3 sync dist/ s3://$BUCKET_NAME/latest/ \
            --delete \
            --cache-control "no-cache, no-store, must-revalidate" \
            --include "*.html"
          if [ -d dist/assets ]; then
            aws s3 sync dist/assets/ s3://$BUCKET_NAME/latest/assets/ \
              --delete \
              --cache-control "public, max-age=3600"
          fi
          echo "BUILD_VERSION=$BUILD_VERSION" >> $GITHUB_ENV
      - name: üì¢ Output Build Version
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        run: |
          echo "## Build Version: $BUILD_VERSION" >> $GITHUB_STEP_SUMMARY
      - name: üîÑ Invalidate CloudFront Cache
        if: ${{ env.PIPELINE_ACTION != 'destroy' }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.infra.outputs.web_cloudfront_distribution_id }} \
            --paths "/*"

  deployment-summary:
    name: üìä Deployment Summary
    needs: [validate-env, deploy-web, determine-action]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: üìù Generate Summary
        run: |
          echo "## üöÄ Deployment Summary for ${{ needs.determine-action.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Action Performed" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.determine-action.outputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìÖ Deployment Time" >> $GITHUB_STEP_SUMMARY
          echo "- $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add deployment status
          if [[ "${{ needs.deploy-web.result }}" == "success" ]]; then
            echo "### ‚úÖ Deployment Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** If the deployment failed due to App Runner being busy, the workflow automatically retries up to 3 times." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Next Steps" >> $GITHUB_STEP_SUMMARY
          ACTION="${{ needs.determine-action.outputs.action }}"
          if [[ "$ACTION" == "deploy" ]]; then
            echo "1. Verify the deployment in the AWS Console" >> $GITHUB_STEP_SUMMARY
            echo "2. Test the application endpoints" >> $GITHUB_STEP_SUMMARY
            echo "3. Monitor CloudWatch metrics for any issues" >> $GITHUB_STEP_SUMMARY
          else
            echo "1. Review the planned changes" >> $GITHUB_STEP_SUMMARY
            echo "2. Approve the changes if they look correct" >> $GITHUB_STEP_SUMMARY
            echo "3. Run the workflow again with 'apply' action" >> $GITHUB_STEP_SUMMARY
          fi 